
Причина подобного заключается в том, что функция setTimeout создаёт замыкание, 
у которой есть доступ к внешней по отношению к ней области видимости, в котором объявляется и используется переменная i. 

Можно исправить такими способами:

1) 
const arr = [10, 12, 15, 21];

for (var i = 0; i < arr.length; i++) {
  (function (i) {
    setTimeout(function () {
      console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`)
    })
  })(i)
}


var являются функциональной переменной области видимости, if/for/while будут доступны во всей функции.
Когда функция тайм-аута выполняется для i = 0, значение i уже достигло 4, поскольку цикл for завершен. 
Следовательно, нужно явно передать значение i.

2)
const arr = [10, 12, 15, 21];

for (let i = 0; i < arr.length; i++) {
    setTimeout(function () {
      console.log(arr[i] > 13 ? `Good: ${arr[i]}` : `Bad: ${arr[i]}`)
    })
}

Если используется ES6 и выше, можно использовать let которое позволяет создавать новую привязку при каждом вызове функции
var-объявление переменной в начале for цикла создает единственную привязку для этой переменной